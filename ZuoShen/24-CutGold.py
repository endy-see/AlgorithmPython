"""
切金条
题目：一块金条切成两半，是需要花费和长度数值一样的铜板。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板
一群人想整分整块金条，怎么分最省铜板？例如，给定数组[10,20,30]，代表一共三个人，整块金条长度为10+20+30=60。
金条要分成10，20，30三个部分。如果，先把长度60的金条分成10和50，花费60，再把长度50的金条分成20和30，花费50，
一共花费110铜板。但是如果先把长度60的金条分成30和30，花费60，再把长度30金条分成10和20，花费30，一共花费90铜板
输入一个数组，返回分割的最小代价
思路：考察对结构和贪心思想。哈夫曼编码找出最小代价。
把数组成小根堆形式，每次弹出两个最小的数，把这两个数的和再加入到堆里，调整成小根堆形式，再弹出两个最小的数，
把这两个数的和再加入到堆里，不断弹出加入。
例子：1，3，6，6，9，16组成一个小根堆。
1. 1和3合并等于4，代价为4。把4加入到小根堆，此时小根堆含有4，6，6，9，16，调成小根堆形式
2. 4和6合并等于10，代价为10。把10加入到小根堆，此时小根堆为10，6，9，16，调成小根堆形式
3. 6和9合并等于15，代价为15。把15加入到小根堆，此时小根堆为10，15，16，调成小根堆形式
4. 10和15合并等于25，代价为25。把25加入到小根堆，此时小根堆为25，16，调成小根堆形式
5. 25和16合并等于41，代价为41。把41加入到小根堆，此时小根堆为41
因此，总共代价为4+10+15+25+41
"""

import heapq


def lessMoney(arr):
    if not arr:
        return 0

    heapq.heapify(arr)
    sum = 0
    while len(arr) > 1:
        cur = heapq.heappop(arr) + heapq.heappop(arr)
        sum += cur
        arr.append(cur)
    return sum


if __name__ == '__main__':
    arr = [3, 5, 2, 7, 0, 1, 6, 4]
    arr = [1, 3, 6, 6, 9, 16]
    print(lessMoney(arr))

