"""
题目：n个骰子的点数
把n个骰子扔在地上，所有骰子朝上面一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率

本质是求数列：f(n) = f(n-1)+f(n-2)+f(n-3)+f(n-4)+f(n-5)+f(n-6)
找到这个规律之后就可以用递归和循环两种不同的方法去写代码

思路：n个骰子的点数和最小值为n，最大值为6n。另外根据排列组合的知识，我们还知道n个骰子的所有点数的排列为6^n
要解决这个问题，我们需要先统计出每个点数和出现的次数，然后把每个点数和出现的次数除以6^n，就能求出每个点数出现的概率
上面思路比较晦涩难懂，用动态规划很好解决
"""


# coding=utf8
def print_probability(n):
    dp = [[0 for i in range(6 * n)] for i in range(n)]

    for i in range(6):
        dp[0][i] = 1
    # print dp
    for i in range(1, n):
        # [0,i-1]的时候，频数为0（例如2个骰子不可能投出点数和为1）
        for j in range(i, 6 * (i + 1)):
            dp[i][j] = dp[i - 1][j - 6] + dp[i - 1][j - 5] + dp[i - 1][j - 4] + \
                       dp[i - 1][j - 3] + dp[i - 1][j - 2] + dp[i - 1][j - 1]

    count = dp[n - 1]
    # 算得骰子投出每一个点数的频数。再除以总的排列数即可得到频率
    return count


# 括号中的数字为骰子的个数。此代码为3个骰子时的情况。
print(print_probability(3))