"""
希尔排序：

时间复杂度：O(n^(1.3-2))  没有快排快 所以较少考
空间复杂度：O(n)  其空间占用主要是临时的数组和递归时压入栈的数据占用：n+logn
非稳定排序

希排也称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本，原理如下：
先将待排序的数组元素分成多个子序列（log n），使得每个子序列的元素个数相对较少，
然后对各个子序列分别进行直接插入排序，待正规待排序序列“基本有序”以后，
最后再对所有元素进行一次直接插入排序
希尔排序的关键不是随便地分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列　实现跳跃式移动　使得排序的效率提高
"""


def ShellSort(arr):
    if not arr or len(arr) < 2:
        return

    # 先生成子序列的跨度
    h = len(arr) >> 1
    while h > 0:
        # 对以h为跨度的子序列做插入排序
        # i是从跨度位置开始 一直往后移动 直到数组尾部
        for i in range(h, len(arr)):
            # 开始执行插入排序了：将anchor的值插入到前面每隔h的位置上
            anchor = arr[i]  # 保存了i位置的值
            j = i - h
            while j >= 0:
                # 从后面往前 找到第一个比anchor小的数 如果当前j位置的值比anchor 则不断往后挪
                if arr[j] > anchor:
                    arr[j + h] = arr[j]  # 将当前较大的的值覆盖后面较小的值
                else:
                    # 注意：这里敢直接break的原因是　一旦找到了第一个比anchor小的值的位置　
                    # 那么该位置之前的必定都是比anchor小的 因为ｉ每次是从ｈ开始，往后遍历　直接插入排序的　
                    # 所以在可实现２个以上元素构成的序列之前　前面的序列都是已经排好序的
                    break

                j -= h
            # 最后挪不动了 说明arr[j]的值已经小于anchor了，则直接将anchor值插入到arr[j+h]的位置即可
            arr[j + h] = anchor  # 这里之所以是j+h，是因为在走到此步之前j被更新成j-h或者i-h了
        h = h >> 1


arr = [85, 65, 97, 76, 13, 27, 49]
ShellSort(arr)
print(arr)
